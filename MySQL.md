# MySQL

## 读取方式

### 顺序

- 书写顺序：select--from--where--group by--having--order by
- 执行顺序：from--where--group by--having--select--order by

### 关联

- from后面的表关联，是自右向左解析的，尽量把数据量小的表放在最右边来进行关联；
- where条件的解析顺序自左向右，把能筛选出小量数据的条件放在where语句的最左边

 

## 索引——数据结构

### 优劣势

1. 优势

   - 高检索效率降低I/O成本

   - 通过索引对数据进行排序，降低排序成本和CPU消耗

2. 劣势

   - 索引要消耗大量额外空间
   - 修改数据时可能带来大量额外开销
   - 人工建立索引费时

### 分类

1. 单值索引
2. 唯一索引
3. 复合索引
4. 基本索引

### B+树

#### 相对于红黑树

- 出度更大，树高更小
- 磁盘按页读取，若数据不在一个磁盘块上则需要寻道，寻道次数与树高成正比
- 符合预读取特性，相邻节点会被预先载入

#### 相对于B树

- 非叶子节点不存贮数据，单一节点储存索引更多，I/O次数更少
- 所有查询都会查到叶子节点，性能稳定
- 所有叶子节点形成有序链表，便于范围查找

### MySQL索引

1. B+树索引

   主索引和辅助索引

2. 哈希索引

   当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引

3. 全文索引

   支持关键词查找，利用倒排索引实现

4. 空间数据索引

### 索引建立

1. 适合建立索引
   - 主键自动建立唯一索引
   - 频发查找的字段
   - 外键关系建立索引
   - 组合索引
   - 有排序和分组诉求
2. 不适合建立索引
   - 表记录太少（300万）
   - 经常增删改的表
   - 字段重复的行太多（索引选择性）

### 索引优化

1. 独立索引
2. 多列索引
3. 索引列顺序
4. 最佳前缀索引、中间兄弟不能断（多值索引）
5. 覆盖索引



## 事务

### 基本要素

1. 原子性：要么全部成功，要么全部失败。
2. 一致性：任何时间任何并发事务数量，事务始终一致，即总资源数不变。
3. 隔离性：同一时间对资源的操作不相互影响，否则串行化。
4. 持久性：事务完成后，对数据的更新必能持久化保存，并不会被回滚。

### 隔离级别

由低到高：

1. 读未提交：可以读取未提交事务的数据
   - 导致脏读
2. 读已提交：一个事务提交之后另一个才能读取
   - 导致不可重复读
3. 重复读：事务开启后不再允许修改操作
   - 导致幻读
4. 序列化：串行

### 事物的实现

1. **原子性**——undo log

   每次的数据变化会生成undo log并先行保存到磁盘上，若需要rollback则根据undo log逆向生成回滚语句；

2. **持久性**——redo log

   - 背景：

     		为了提高性能，InnoDB提供了缓冲池（buffer pool），缓冲池里面包含了磁盘数据页的映射，这样就可以当作缓存来使用。当用户进行读数据操作时，MySQL会先从缓冲池里读取，如果没有该数据的话在从磁盘读取数据放入缓冲池；当用户进行写数据操作时，数据同样会先写入缓冲池当中，之后缓冲池里面的数据才会定期同步到磁盘当中去。

   - 解决方案：

     ​		当写操作写入缓冲池中后，先将该操作持久化至redo log。（redo log大小远小于一页，且顺序存储，速度快）

3. **隔离性**——（读写锁、MVCC）

   - 读未提交：

     读不加锁，写加锁，读写并行；

   - 读已提交（innoDB采用MVCC）：

     1. 读写锁实现：读不加锁，写加锁，读写分离；
     2. MVCC实现：每次进行select操作时都会在其生成一个新的版本号，这样每次select读到的不是一个副本而是不同的副本。这样在每次select之间假使有其他事物更新我们读取的数据并提交后，就出现了不可重复读的现象；
     
   - 可重复读：

     1. 读写锁实现：读加锁，写加锁，读读共享，读写串行；
     2. MVCC实现：每次出现多读的情况对数据库进行一次快照，读取快照中的内容；

   - 解决幻读：

      1. 串行化：绝对不会造成不一致问题，但性能差；
      2. MVCC：快照时只照版本号小于当前版本号的内容。

4. **一致性**——通过其他三个性质保证



## 性能优化

### 使用Explain进行分析

重要字段有：

- select_type
- key
- rows

### 优化数据访问

1. 减小请求数据量
   - 返回必要数据
   - 缓存重复查询数据
2. 减少服务器端扫描的行数

### 重构查询方式

减少锁竞争：

1. 切分大查询
2. 分解大链接查询

## 存储引擎

### InnoDB

1. 四个隔离级别
2. 主索引采用聚簇索引，索引中保存数据
3. 采用可预测性读、自适应哈希索引、插入缓冲区
4. 支持外键
5. 支持在线热备份

### MyISAM

1. 设计简单，适用于只读数据、表较小、可容忍修复操作
2. 不支持事务
3. 只等对整张表加锁
4. 表保存为文件形式，适用于跨平台数据迁移

### 对比

- 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。
- 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。
- 外键：InnoDB 支持外键。
- 备份：InnoDB 支持在线热备份。
- 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
- 其它特性：MyISAM 支持压缩表和空间数据索引。



## 复制

### 主从复制

- **binlog线程**：将主服务器上的数据更改写入二进制日志中
- **I/O线程**：从主服务器上读取二进制日志，写入从服务器的中继日志
- **SQL线程**：读取中继日志，将操作再服务器中重放

### 读写分离

- 主从服务器分别负责读写，缓解锁征用
- 从服务器使用MyISAM，节约系统开销
- 增加冗余，提高可用性



## 连接模式

### socket（默认）

​	mysql服务启动的时候，socket文件的生成目录可以在[mysqld]上指定，如果没有指定，默认是**/tmp/mysql.sock**；

### TCP/IP（通过-h指定）

​	mysql登陆的时候，指定参数-h，会使用tcp/ip的方式连接，如果没有指定端口的话，默认是使用3306端口







