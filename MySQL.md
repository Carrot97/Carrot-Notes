# MySQL

## 组件

1. 连接器

   > 链接server，并权限验证。
   >
   > #### socket（默认）
   >
   > ​	mysql服务启动的时候，socket文件的生成目录可以在[mysqld]上指定，如果没有指定，默认是**/tmp/mysql.sock**；
   >
   > #### TCP/IP（通过-h指定）
   >
   > ​	mysql登陆的时候，指定参数-h，会使用tcp/ip的方式连接，如果没有指定端口的话，默认是使用3306端口

2. 查询缓存（不推荐使用）

   - 对写操作压力大的表，缓存经常失效
   - 缓存命中率低

3. 分析器

   > 语法检错

4. 优化器

   > 确定执行计划

5. 执行器

   > 开始执行前要判断表权限



## 工作方式

### select

顺序

- 书写顺序：select--from--where--group by--having--order by
- 执行顺序：from--where--group by--having--select--order by

关联

- from后面的表关联，是自右向左解析的，尽量把数据量小的表放在最右边来进行关联；
- where条件的解析顺序自左向右，把能筛选出小量数据的条件放在where语句的最左边

### update

1. 内存中查找当where的行；
2. 若并不在内存中则取磁盘读；
3. 修改对应的字段；
4. 跟新至内存；
5. 写入redolog，处于prepare阶段；
6. 写binlog；
7. 提交事务。

### 两阶段提交

1. 更新流程中写入redo log的过程拆成了两个步骤prepare和commit。如果不使用两阶段提交，数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。
2. 让redo log和binlog逻辑上保持一致. 如果在commit时崩溃了, 虽然没有commit, 但是prepare和binlog完整, 所以重启之后会自动commit
3. 如果redo log里面的事务是完整的, 也就是有了commit标识, 则直接提交
   如果redo log里面的事务只有完整的prepare, 则判断对应的事务是否存在完整的binlog，如果是, 则提交事务，否则,回滚事务

## 日志

### redolog和binlog

1. redo是物理日志，bin是逻辑日志；
2. redo是引擎持有的，bin是server层实现的，所有引擎都可用；
3. redo循环写，bin一直写，使用bin来实现归档。

### binlog in redo

1. 事务的commit过程：2次IO操作，保证了Binlog和引擎中数据的一致性。但是在事务的提交过程中，2次IO写操作对事务的提交性能有很大的影响。
2. binlog in redo：当事务提交时，将事务的Binlog Events写入到Redo中，然后将Redo持久化。而Binlog文件 则采用异步的方式，用单独的线程周期性的持久化到存储中。因此事务的提交过程中，减少了一次IO。



## 索引——数据结构

### 优劣势

1. 优势

   - 高检索效率降低I/O成本

   - 通过索引对数据进行排序，降低排序成本和CPU消耗

2. 劣势

   - 索引要消耗大量额外空间
   - 修改数据时可能带来大量额外开销
   - 人工建立索引费时

### 分类

1. 单值索引
2. 唯一索引
3. 复合索引
4. 基本索引

### B+树

#### 相对于红黑树

- 出度更大，树高更小
- 磁盘按页读取，若数据不在一个磁盘块上则需要寻道，寻道次数与树高成正比
- 符合预读取特性，相邻节点会被预先载入

#### 相对于B树

- 非叶子节点不存贮数据，单一节点储存索引更多，I/O次数更少
- 所有查询都会查到叶子节点，性能稳定
- 所有叶子节点形成有序链表，便于范围查找

#### B+树存储能力

- innodb引擎一页大小16k；
- 假设一行记录数据大小为1k，单个叶子节点（页）中的记录数=16K/1K=16；
- 假设主键为bigint占8k，指针占6k，一页能存放16384/14=1170个指针；
- 能存放的总记录数大约为(n-1)1170*16条记录。

### MySQL索引

1. B+树索引

   主索引和辅助索引

2. 哈希索引

   当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引

3. 全文索引

   支持关键词查找，利用倒排索引实现

4. 空间数据索引

### 索引建立

1. 适合建立索引
   - 主键自动建立唯一索引
   - 频发查找的字段
   - 外键关系建立索引
   - 组合索引
   - 有排序和分组诉求
2. 不适合建立索引
   - 表记录太少（300万）
   - 经常增删改的表
   - 字段重复的行太多（索引选择性）

### 索引优化

1. 独立索引
2. 多列索引
3. 索引列顺序
4. 最佳前缀索引、中间兄弟不能断（多值索引）
5. 覆盖索引

### 自增主键

1. 唯一性约束；
2. 顺序添加，加满一页才会开辟下一页，提高插入性能。



## 事务

### 基本要素

1. 原子性：要么全部成功，要么全部失败。
2. 一致性：任何时间任何并发事务数量，事务始终一致，即总资源数不变。
3. 隔离性：同一时间对资源的操作不相互影响，否则串行化。
4. 持久性：事务完成后，对数据的更新必能持久化保存，并不会被回滚。

### 隔离级别

由低到高：

1. 读未提交：可以读取未提交事务的数据
   - 导致脏读
2. 读已提交：一个事务提交之后另一个才能读取
   - 导致不可重复读
3. 重复读：事务开启后不再允许修改操作
   - 导致幻读
4. 序列化：串行

### 事物的实现

1. **原子性**——undo log

   每次的数据变化会生成undo log并先行保存到磁盘上，若需要rollback则根据undo log逆向生成回滚语句；

2. **持久性**——redo log

   - 背景：

     > 为了提高性能，InnoDB提供了缓冲池（buffer pool），缓冲池里面包含了磁盘数据页的映射，这样就可以当作缓存来使用。当用户进行读数据操作时，MySQL会先从缓冲池里读取，如果没有该数据的话在从磁盘读取数据放入缓冲池；当用户进行写数据操作时，数据同样会先写入缓冲池当中，之后缓冲池里面的数据才会定期同步到磁盘当中去。

   - 解决方案：

     ​		当写操作写入缓冲池中后，先将该操作持久化至redo log。（redo log大小远小于一页，且顺序存储，速度快）

3. **隔离性**——（读写锁、MVCC）

   - 读未提交：

     ​	读不加锁，写加锁，读写并行；

   - 读已提交：

     1. 读写锁实现：写加行级排他锁直到事务结束，读加行级共享锁读完就释放；
     2. *MVCC实现：每次读取前进行快照；
     
   - 可重复读：

     1. 读写锁实现：读加锁，写加锁，读读共享，读写串行；
     2. *MVCC实现：多读时第一次读进行快照；

   - 解决幻读：

      1. 串行化：绝对不会造成不一致问题，但性能差；
      2. *读写锁实现：可重复读+间隙锁
      3. MVCC实现：快照时只照版本号小于当前版本号的内容。

4. **一致性**——通过其他三个性质保证



## 性能优化

### 使用Explain进行分析

重要字段有：

- type

  1. const：主键精确扫描
  2. eq_ref：唯一索引精确扫描
  3. ref：非唯一索引精确扫描
  4. range：索引范围查找
  5. index：查找所有索引树
  6. all：全表扫描

- key

- rows

  > 只是解释器器估算的需要扫描行数，跟实际表现关系不大

### 优化数据访问

1. 减小请求数据量
   - 返回必要数据
   - 缓存重复查询数据
2. 减少服务器端扫描的行数

### 重构查询方式

减少锁竞争：

1. 切分大查询
2. 分解大链接查询

## 存储引擎

### InnoDB

1. 四个隔离级别
2. 主索引采用聚簇索引，索引中保存数据
3. 采用可预测性读、自适应哈希索引、插入缓冲区
4. 支持外键
5. 支持在线热备份

### MyISAM

1. 设计简单，适用于只读数据、表较小、可容忍修复操作
2. 不支持事务
3. 只等对整张表加锁
4. 表保存为文件形式，适用于跨平台数据迁移

### 对比

- 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。
- 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。
- 外键：InnoDB 支持外键。
- 备份：InnoDB 支持在线热备份。
- 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
- 其它特性：MyISAM 支持压缩表和空间数据索引。



## 复制

### 主从复制

- **binlog线程**：将主服务器上的数据更改写入二进制日志中
- **I/O线程**：从主服务器上读取二进制日志，写入从服务器的中继日志
- **SQL线程**：读取中继日志，将操作再服务器中重放

### 读写分离

- 主从服务器分别负责读写，缓解锁征用
- 从服务器使用MyISAM，节约系统开销
- 增加冗余，提高可用性



## 设计三大范式

1. 第一范式（保证每列的原子性）

   > 所有字段值都是不可分解的原子值。

2. 第二范式（确保每列都与主键相关）

   > 主要针对联合主键，在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。（一对多关系）

3. 第三范式（确保每列都和主键列直接相关,而不是间接相关）

   > 多对一关系









