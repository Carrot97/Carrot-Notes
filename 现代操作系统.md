# 现代操作系统

## 6 操作洗系统调度

### 6.3 单核调度策略

#### 6.3.4 实时调度

>  如果存在一种调度策略，那么所有任务CPU利用率之和U一定小于1

##### 速率单调(Rate-Monotonic,RM)

策略：静态优先级调度策略。基于优先队列，优先（抢占式）调度周期短的任务。

极限：N*（2^(1/N)-1）。当N=2时为83%，当N趋近于69%。极限之内RM策略一定可以实现调度。

优化：先算是否在极限之内，如果不在则选择动态调度算法。

##### 最早截止时间优先(Earliest Deadline First,EDF)

策略：动态优先级调度策略。优先调度截止时间早的任务。

优势：在U<=1的情况下是最优策略。

劣势：在U>1的情况下存在多米诺效应。

#### 6.3.5 其他调度

> 通过一种调度策略同时满足批处理、交互式和实时任务

##### 借用虚拟时间(Borrowed Virtual Time,BVT)

策略：基于虚拟时间进制，允许任务减少一定的虚拟时间开始。

优势：同时保证公平共享调度又满足实时性。



### 6.4 多核调度策略

#### 6.4.1 负载分担(load sharing)

策略：每当其中一个CPU需要任务时，采用单核调度策略调度。

优势：1. 设计简单；2. 不会出现CPU浪费。

劣势：同一任务前后两个时间片不在一个核执行，导致缓存失效，TLB刷新，切换开销增大。

#### 6.4.2 群组调度(gang scheduling)

策略：将关联任务分为一个组，尽量同时调度一个组。

劣势：可能出现无关联任务相互等待，导致CPU浪费。

#### 6.4.3 两级调度(two-level scheduling)

策略：层次化调度记住，每个核心维护自己的单核调度器，全局调度器向单核调度器调度任务。

优势：多核与单核解耦，实现更加灵活。

#### 6.4.4 负载追踪与负载均衡

> 将负载高的核心上的任务迁移至负载低的核心。

##### 负载追踪

- 调度队列粒度负载追踪(linux3.8以前)

  劣势：不够精确，无法选出合适任务进行迁移。

- 调度实体粒度负载追踪(linux3.8以后)

  负载函数：可运行时间/1024 *CPU容量。

  策略：计算任务首次调度以来的累计负载，L‘ = L * y + Ln。

  优势：开销小，粒度小。

##### 负载均衡

Linux负载均衡架构：NUMA域 --> 物理CPU域 --> 逻辑CPU域（每个上层管理两个下层，仅允许空闲的CPU拉取任务）

策略：为每层级间设置不同的触发阈值，高层间负载均衡的开销。

#### 6.4.5 能耗感知调度(Energy Aware Scheduling,EAS)

> 嵌入式设备中存在大小核架构和性能点（切换CPU容量和功率）
>
> 注意：同一性能域必须同时保持在相同频率。

策略：基于完全公平调度，从一个核心迁移至剩余容量较多的核心，来降低功耗（降低性能点）。

适用场景：中、低负载场景。linux在高负载时(任一CPU>80%)开启负载均衡关闭EAS，低负载时关闭负载均衡开启EAS。



### 6.5 调度进阶机制

#### 6.5.1 处理器亲和性

允许开发者设置任务允许分配的CPU核心。

注意：Redis采用的这种方法绑定CPU核心。

#### 6.5.2 调度策略设置

| 调度器 | 调度策略       | 描述             |
| ------ | -------------- | ---------------- |
| CFS    | SCHED_OTHER    | 公平分时         |
| CFS    | SCHED_BATCH    | 批处理           |
| CFS    | SCHED_IDLE     | 后台任务         |
| RT     | SCHED_FIFO     | 先入先出多级队列 |
| RT     | SCHED_RR       | 时间片           |
| DL     | SCHED_DEADLINE | EDF              |

优先级顺序：DL > RT > CFS



### 6.6 现代调度器

#### 6.6.1 Linux调度器

##### O(n)调度器（2.4版本后）

策略：运行时计算动态优先级，选取优先级最高的任务进行调度。

劣势：1. 调度开销过大；2. 多核扩展性差（修改公共队列导致其他核缓存失效）。

##### O(1)调度器（2.6.0版本后）

策略：两个140级的多级队列（激活队列和过期队列），由搞到低依次调度，调度后放入过期队列，定期反转队列。

劣势：1. 使用启发式算法判断交互式任务，计算开销大；2. 静态时间片增加的响应时间。

##### 完全公平调度器（2.6.23版本后）

动态时间片：基于步幅调度，通过调度周期反向计算时间片（周期内所有任务调度一遍，默认6ms，最小时间片默认0.75ms）。

使用红黑树作运行队列：键为虚拟时间，值为任务实体。插入开销仅为O(logN)。

阻塞唤醒：阻塞唤醒后会设置初始虚拟时间。

#### 6.6.2 macOS/IOS调度器（GCD）

机制：多队列 + 线程池，开发者只需要提交代码片段，执行线程由操作系统决定。

队列：UserInteractive、UserInitiated、Default、Utility和Background，每个队列又分为串行队列和并发队列。



## 7 进程间通信

### 7.1 基本概念

#### 7.1.1 共享内存与操作系统辅助传递

##### 共享内存

- 优势：共用一块避免内存拷贝
- 劣势：逻辑复杂，无法指针传递

##### 操作系统辅助传递

- 操作系统抽象后通信更简单
- 安全性更强
- 进程通信避免不安全情况

#### 7.1.2 控制流转移

操作系统负责阻塞和唤醒发送和接收进程，避免进程轮询。

#### 7.1.3 单向与双向

#### 7.1.4 同步与异步



### 7.2 宏内核进程间通信

#### 7.2.1 管道

> 内存中创建文件描述符，一个进程负责写（字节流），一个进程负责读。

##### 匿名管道

父进程通过fork将文件描述符的权限传递给子进程，父子进程要分别关闭读端口和写端口

##### 命名管道

 建立全局命名文件，实现任意两个进程的通信。

#### 7.2.2 消息队列

- 多进程通信，注册即用
- 同步与异步可选
- 有最大空间限制
- 存在拷贝开销

#### 7.2.3 信号量

- 主要用户同步
- 信号量由内核维护
- 通过PV操作进行加减
- 无法进行操作将阻塞

#### 7.2.4 共享内存

- 将多个进程虚拟地址空间映射到相同物理页
- linux对共享内存进行了多层封装为了利用内存动态分配与换页机制

#### 7.2.5 信号

- 主要用于主动通知
- 发送：内核为每个线程和进程准备一个信号事件队列，信号将事件添加至队列中。
- 屏蔽：利用系统调用可以暂时屏蔽信号，但解除屏蔽还需要处理。
- 处理：在系统调用返回用户态的时刻会检查是否有需要处理的信号，用户可以注册信号处理函数。
- 重入：多个信号一起触发时导致公共资源不一致问题。

#### 7.2.6 套接字

- 唯一一个可以跨主机进程间通信的方式。



# 8 同步原语

> 互斥访问、有限等待、空闲让进

### 8.1 互斥锁

#### 8.1.1 硬件实现

机制：在进入临界区之前关闭中断，进制调度器进行调度。出临界区时开启中断。

缺点：不支持多核。

#### 8.1.2 皮特森算法

策略：维护一个线程申请进入临界区的数组和一个当前偏向变量，当对方不申请进入临界区或偏向变量偏向自己时，可以进入临界区。

要点：每次循环要将偏向变量设置为对方，避免同时进入临界区。

缺点：执行必须按照顺序执行，java等语言中有指令重排。

#### 8.1.3 软硬件协同

##### 原子操作

CAS、FAA

##### 自旋锁

策略：循环CAS修改变量上锁

缺点：缺乏公平性

##### 排号锁

策略：锁维护当前持有锁的编号和下一个被取得号，线程循环FAA取号上锁

### 8.2 条件变量

#### 8.2.1 使用方式

需要配合互斥锁使用，在临界区缺乏继续执行条件时挂起并主动让出锁，等待满足条件时被唤醒。

#### 8.2.2 实现方式

- 维护等待队列
- 挂起时需要借助操作系统原子性地挂起并释放锁
- 挂起操作需要在临界区内完成，否则可能挂起晚于唤醒

### 8.3 信号量

#### 8.3.1 使用方式

基于PV操作对资源进行同步

#### 8.3.2 实现方式

- 基于互斥锁、条件变量和计数器实现

- value为正数表示资源数量、为负数表示等待线程的数量（相当于欠着资源等有的时候还上）

- wakeup表示有线程等待时可用资源的数量

### 8.4 读写锁

> 读读并行、写写互斥、读写互斥

#### 8.4.1 偏向读读写锁

- 读者加锁时，检查持有锁的读者数量，如果自己是第一个则尝试加写锁
- 读者释放锁时，检查持有锁的读者数量，如果自己是最后一个则尝试释放写锁

#### 8.4.2 偏向写读写锁

- 读者加锁时需要查看有无等待的写者，有则等待在写条件上
- 读者释放锁时需要查看读者数量，如果自己是最后一个则唤醒读条件上的线程
- 写者加锁是需要先查看有无之前的写着，有则等待在写条件，再查看有无读者，有则等待在读条件
- 写者释放锁是需要唤醒所有在等待在写条件上的线程

### RCU

机制：读写不加锁，写在新内存区域后修改指针（依赖原子性的地址对齐）。

优势：读者开销更小

缺点：地址对齐必须原子性，回收就内存时机无法确定（宽限期）。

### 8.5 管程

一种抽象格式，使得开发者不需要关注线程如何同步，只需要调用即可。

在Java中synchronized关键字实现了管程。

### 8.6 同步带来的问题

#### 8.6.1 死锁

##### 死锁的条件

- 互斥访问
- 持有并等待
- 资源非抢占
- 循环等待

##### 死锁预防

- 避免互斥访问：采用代理方式访问资源
- 不允许持有并等待：一次性分配资源
- 允许资源抢占
- 避免循环等待：顺序分配资源

##### 死锁避免

银行家算法

#### 8.6.2 活锁

> 出现尝试加锁->失败的循环中

可以采用顺序分配避免

#### 8.6.3 优先级反转

> 由于高优先级线程需要等待锁，导致低无关低优先级线程先执行

##### 不可抢占临界区协议

一旦一个线程获取了锁就不允许调度其他线程

##### 优先级继承协议

持有锁的低优先级继承高优先级等待锁的线程的优先级

##### 优先级置顶协议

将持有锁线程的优先级置为可能竞争该锁的线程中最高的优先级

### 8.7 Linux中的futex

> 通过futex机制实现不加锁的线程挂起和唤醒
>
> 避免互斥锁中循环等待的情况，和条件变量中原子释放锁和挂起

##### futex_wait(int *uaddr, int val)

验证uaddr上的值等于val时挂起

##### futex_wake(int *uaddr)

唤醒挂起在uaddr上的线程



## 9 文件系统

### 9.1 基于inode的文件系统

#### 9.1.1 inode

- 块4kb，指针8字节

- 12个直接指针
- 3个间接指针
- 1个二级间接指针

- 元数据：文件模式、链接个数、文件大小、用户组、修改时间

##### linux中的文件类型

| 文件类型     | 文件用途     |
| ------------ | ------------ |
| 常规文件     | 保存数据     |
| 目录文件     | 组织文件     |
| 符号链接文件 | 保存符号链接 |
| FIFO文件     | 命名管道     |
| 套接字文件   | 传递数据     |
| 字符设备文件 | 访问字符设备 |
| 块设备文件   | 访问块设备   |

#### 9.1.2 文件名与目录

> 文件名保存在目录中，不保存在inode数据结构中

目录项：inode号、目录项长度、文件名长度、文件名

注意：目录文件中默认保存"."和".."目录项

#### 9.1.3 硬链接与符号链接

##### 硬链接

在目标路径中创建一个目标文件的目录项

##### 符号链接

创建一个指向目标文件的inode数据结构

#### 9.1.4 存储布局

- 超级块：文件系统信息、最大支持inode数量、最大支持块数量等
- 块分配信息：用位图表示
- inode分配信息：用位图表示
- inode表
- 文件数据块



### 9.2 虚拟文件系统

#### 9.2.1 面向文件系统的接口

##### VFS内存数据结构

- VFS超级块：文件系统版本、挂载点信息等
- VFSinode：比普通inode对一些信息
- VFS文件数据管理：使用基数树建立页缓存
- VFS目录项：保存文件名与inode号之间的映射

#### 9.2.2 面向应用程序的接口

##### 文件描述符

一个整数，在系统调用时用于认证和映射。操作系统代理对文件的操作。

#### 9.2.3 页缓存、直接I/O与内存映射

##### 页缓存

##### 直接I/O与缓存I/O

可以通过打开文件时附带O_DIRECT标志来禁用操作系统的页缓存，使得应用程序可以实现自己的页缓存

##### 内存映射

通过建立内存页与物理块之间的映射来以内存的方式访问文件

#### 9.2.4 多种文件系统的组织和管理

##### 挂载点

- windows通过盘符来进行隔离
- linux维护VFS文件系统树，通过挂载的方式灵活任何目录上

#### 9.2.5 伪文件系统

允许应用程序通过读取写入文件的方式读取和修改内核提供的信息



### 9.3 其他文件系统

#### 9.3.1 FAT文件系统

##### 存储布局

> 引导记录-FAT1-FAT2-根目录-数据区

根目录以目录项为单位进行存储

主要包括：8.3文件名、属性、创建时间、访问时间、数据起始簇号、文件大小等

##### 短文件名（8.3格式）

8个长度文件名 . 3个长度格式

超过长度用 ”前6个文件名~数量.3个长度格式“ 代替

另外开辟新的目录项用来存放整个文件名，最多不超过20个目录项，255个unicode字符

##### FAT格式

每个FAT表项都记录了一个簇号，使得多个簇之间串联成链表，从而存放大文件

##### 缺点

- 链表查找效率低
- 目录数据不足
- 簇大小不足

#### 9.3.2 NTFS

##### 存储布局

> 引导-数据区-MFT-数据区-MFT镜像-数据区

##### MFT

MFT是一种关系性数据库，每一条记录都代表了一个文件。

其中前16个为保留记录，第1条为MFT自己

当文件大小超过一条记录的容量时，将文件拆分存入数据区，并通过B树建立索引

##### 多数据流

文件可以根据需求差分成多个条串保存不同的位置

##### 压缩和稀疏文件

开启压缩功能后，存入压缩，取出解压

不存储稀疏文件中的大片连续0

#### 9.3.3 FUSE

当VFS根据路径找到文件由FUSE模块管理时，FUSE会将命令加入与FUSE服务器之间（用户态）共享队列

##### 缺点

- 频繁的用户态与内核态切换
- 大量的数据拷贝







