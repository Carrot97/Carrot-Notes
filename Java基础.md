# Java基础

##  java基本数据类型

1. **byte**：1字节
2. **short**：2字节
3. **int**：4字节
4. **long**：8字节
5. **char**：2字节
6. **float**：4字节
7. **double**：8字节
8. **boolean**：1字节

Java采用Unicode编码，每字节4比特



## final和static关键字

1. **final**：
   - 修饰变量：常量，无法修改
   - 修饰方法：最终方法，无法被重写
   - 修饰类：最终类，无法被继承（String）
2. **static**：
   - 修饰变量：静态变量，实例共享
   - 修饰方法：静态方法，通过类名访问，不能在其中访问非静态成员变量和方法
   - 修饰代码块：类初次被加载的时候执行静态代码块，且只会执行一次



## 面向对象三大特征

### 1 封装

把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

### 2 继承

面向对象编程 (OOP) 语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

### 3 多态

实现多态，有二种方式，覆盖，重载。
覆盖，是指子类重新定义父类的虚函数的做法。

重载，是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。
其实，重载的概念并不属于“面向对象编程”，重载的实现是：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数：function func(p:integer):integer;和function func(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的（记住：是静态）。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！

真正和多态相关的是“覆盖”。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态（记住：是动态！）的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚邦定）。结论就是：重载只是一种语言特性，与多态无关，与面向对象也无关！引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚邦定，它就不是多态。”



## Java中操作字符串都有哪些类

String、StringBuffer（线程安全Synchronize）、StringBuilder（线程不安全）



## Java的I/O流分类

- 按照流的流向分，可以分为输入流和输出流；
- 按照操作单元划分，可以划分为字节流和字符流；
- 按照流的角色划分为节点流和处理流。



## HashMap

- **实现类**
- **继承于AbstractMap抽象类**
- **使用数组，链表，（红黑树java8）实现**
- **数组初始长度16**
- **数组长度只能是2的次方（最大30）**
- **使用红黑树代替长度8（含）以上的链表**
- **使用链表代替长度6（含）以下的红黑树**
- **map长度64以下时，出现hash冲突不使用红黑树，直接扩容**
- **每次扩容原长度的100%**
- **默认负载因子0.75**
- **允许null存在**
- **非线程安全**

追加问题：

1. **put()过程**：
   1. 初始化
   2. hash运算
   3. 若未碰撞直接保存
   4. 若碰撞先看是链表还是红黑树
   5. 链表若相等则替换，不相等则判断是否大于8，大于转为红黑树，小于创建新节点
   6. 红黑树检测是否相等，不相等创建新节点
   7. 判断是否需要扩容

2. **线程不安全问题体现**：

   - **jdk1.7** 头插法，resize时会出现环形链表

   - **jdk1.8** 尾插法，put时出现值覆盖

3. **插入key为null**：

   存在table[0]的链表中

4. **容量为2的幂次**：
   - 位运算速度更快；
   - 分布更加均匀；
   - 扩容时一半的数迁移，更平均。

## ConcurrentHashMap原理

- put()过程：
  1. 计算哈希值
  2. 死循环
     1. 检查初始化，CAS初始化
     2. 检查桶头是否为空，空则CAS直接插入
     3. 检查是否正在扩容，是则帮助扩容
     4. 加锁插入
     5. 检查换树
  3. 容量+1
  
- addCount()过程：
  1. CAS加baseCount，成功则退出
  2. 计算随机索引，加cell，成功则退出
  3. 进入fullAddCount函数
     1. 为空先初始化
     2. 不为空CAS加
     3. 加失败且没到cpu核数，扩容
  4. 计算容量
  5. 计算是否达到阈值，是否正在扩
  6. 能扩就扩，不能扩协助扩容
  
- transfer()扩容过程：

  1. 根据cpu核数计算每个线程扩容大小（最少16）

  2. CAS分配具体区域（倒叙）

  3. 扩容

     - 判断桶位置是否为空
     - 桶位置加锁迁移

     - 在迁移桶第一个位置放置forward节点表示正在迁移

## 抽象类和抽象方法

- 抽象类可以没有抽象方法，但没有意义
- 有抽象方法必须是抽象类，否则编译不通过



## 抽象类和接口的区别。

1. 抽象类可以有构造函数。
3. 抽象类中可以有普通成员变量和普通方法。
4. 抽象类可以有public和protected。
4. 抽象类中可以有静态方法。
5. 单继承和多实现



## Atomic类如何保证原子性

通过CAS(compare and set)原语， 通过储存期望值保证原子性。

- Unsafe类：native方法，直接对内存操作

- 自旋锁：一直进行比较直至更新成功

缺点：

1. 循环时间长开销大
2. 无法保证多资源原子性
3. ABA问题：主要出现在原子引用问题

解决ABA问题：

1. 增加时间戳



## 为什么要使用线程池

- 时间上，减少线程的创建和销毁次数
- 空间上，线程多次使用减少了线程的数量，减少了空间消耗
- 整体上，可根据需要调整数量，更加灵活



## 泛型的好处和实现

好处：

1. 简单易用，提高代码重用率
2. 安全

实现：利用类型擦除实现+自动类型转换



## 创建对象的方式

1. new
2. Class对象的newInstance方法
3. 对象的反序列化
4. Object对象的clone方法



## Object类的方法

1. clone
2. finalize
3. getClass
4. toString
5. equals
6. hashCode
7. wait
8. notify
9. notifyAll

## 重写equal为什么还要重写hashcode

默认hashcode使用对象地址计算，只重写equal会出现equal却hashcode不一样的情况。

## 异常和错误

- 异常：可预测和恢复的问题（轻度、中度），例如：空指针，算数异常，数组越界；
- 错误：大部分为JVM问题，例如：OOM，SOF等，可以catch但处理不了。



## OOM的原因

- 栈：线程请求栈深度大于JVM栈深度；
- 堆：无法GC，无法扩展；
- 方法区：加载过多类、常量、静态变量。



## 内存泄漏的原因

1. 静态成员变量引用对象；
2. String.intern()，常量池不GC；
3. 资源未关闭。



## 依赖注入

在对象进行构造（需要）时，动态地为其提供其成员对象

spring解决循环依赖：**https://my.oschina.net/zhangxufeng/blog/3096394**



# JUC

## 1. 多线程的实现方式

1. 继承Thread类并实现run()方法
   - new Thread创建线程，start方法使线程进入就绪状态。
2. 实现Runable接口并实现run()方法
   - 将子类对象传递给Thread的构造函数。
3. 实现Callable接口，可以有返回值，返回值用FutureTask封装
4. 使用线程池
   - 线程池只能放入Runable和Callable接口线程。

## 2. 线程安全的定义

​	当多个线程访问某个方法时，不管你通过怎样的调用方式或者说这些线程如何交替的执行，我们在主程序中不需要去做任何的同步，这个类的结果行为都是我们设想的正确行为，那么我们就可以说这个类是线程安全的。

## 3. 线程的状态

1. NEW
2. **RUNNABLE**
3. **RUNNING**
4. **BLOCKED**
   - 等待阻塞：运行到wait()方法
   - 同步阻塞：获取锁失败
   - 其他阻塞：执行sleep()或join()方法、发出I/O
5. DEAD

## 4. synchronized与lock的异同

1. ### synchronized

   synchronized的实现原理：

   ​		方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。

   ​		代码块的同步是利用monitorenter和monitorexit这两个字节码指令。它们分别位于同步代码块的开始和结束位置。当jvm执行到monitorenter指令时，当前线程试图获取monitor对象的所有权，如果未加锁或者已经被当前线程所持有，就把锁的计数器+1；当执行monitorexit指令时，锁计数器-1；当锁计数器为0时，该锁就被释放了。如果获取monitor对象失败，该线程则会进入阻塞状态，直到其他线程释放锁。


   1. 使用JVM实现，无需担心没有释放锁而导致死锁（monitor对象）

   2. 使用范围：

      - 代码块（锁：synchronized括号内的对象）

      - 实例方法（锁：实例对象）

      - 类（Class对象）

        只有同步类，其不同实例才会被同步

      - 静态方法（Class对象）

   3. 不可中断（等待的线程一直等待）

   4. 可重入：

      ​		重入锁实现可重入性原理或机制是：每一个锁关联一个线程持有者和计数器，当计数器为 0 时表示该锁没有被任何线程持有，那么任何线程都可能获得该锁而调用相应的方法；当某一线程请求成功后，JVM会记下锁的持有线程，并且将计数器置为 1；此时其它线程请求该锁，则必须等待；而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增；当线程退出同步代码块时，计数器会递减，如果计数器为 0，则释放该锁。

   5. 非公平锁

   ### Reentrantlock

   实现原理：

   1. 未竞争到锁的线程将会被CAS为一个链表结构并且被挂起；
   2. 竞争到锁的线程执行完后释放锁并且将唤醒链表中的下一个节点；
   3. 被唤醒的节点将从被挂起的地方继续执行逻辑。

   特点：

   1. 使用JDK实现，属于java.util.concurrent包
   2. 可以中断（等待的线程等待一段时间后去干别的事）
   3. 可重入
   4. 公平锁或非公平锁
   5. 可绑定多个条件

## 5. sleep和wait的区别

### sleep

1. sleep是Tread的静态方法，可能抛出中断异常，由于不能跨线程传播所以必须本地处理。可能造成资源未关闭
2. sleep不会释放锁。
3. sleep(0)表示触发操作系统立刻重新进行一次CPU竞争，竞争的结果也许是当前线程仍然获得CPU控制权，也许会换成别的线程获得CPU控制权。

### wait

1. wait是Object的方法，必须用在同步代码块中。
2. wait释放锁。

### wait和lock的区别

1. lock尝试获取锁，wait释放锁
2. lock停止运行是**阻塞状态blocked**，wait停止运行是**等待waiting**
3. lock的作用是保护多线程访问的共享资源，而wait的作用是用于多线程之间的线程通信，作用不一样



## 6. 线程池

### 1 线程池执行逻辑

- 若线程数量少于**核心线程数**，就创建新的核心线程来执行新任务；
- 若线程数量大于等于**核心线程数**，但**缓冲队列**未满，则将任务添加至缓冲队列；
- 若线程数量大于等于**核心线程数**但小于**最大线程数**，且**缓冲队列**已满，则创建新的非核心线程执行任务；
- 若线程数量等于**最大线程数**，且**缓冲队列**已满，则根据拒绝策略拒绝任务。

### 2 拒绝策略

- 调用者运行策略：不抛弃，不异常，将任务回退给main线程；

- 终止策略：直接抛异常；
- 丢弃策略：直接丢弃任务；
- 丢弃等待最久任务策略。

### 3 阻塞队列

​	永远保证只有一个线程能够进行队列的出队和入队，也就是绝对的线程安全。

### 4 核心线程数

​	计算密集型为CPU核数+1，IO密集型为2*CPU核数



## 锁的分类

1. 线程是否要锁住同步资源

   - 锁住：**悲观锁**
     - 思想：认为自己在使用数据的时候一定有别的线程来修改数据；
     - 适用场景：多写；
     - 代表：synchronized、ReentrantLock。
   - 不锁：**乐观锁**，适用于多读场景
     - 思想：认为自己在使用数据时不会有别的线程修改数据；
     - 适用场景：多读；
     - 代表：原子类。

2. 锁住同步资源失败，线程是否需要阻塞

   - 阻塞

   - 不阻塞

     - **自旋锁**（CAS）

       思想：在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。

     - **适应性自旋锁**

       思想：之前成功自旋的线程自旋，经常不成功的阻塞。

3. 多个线程竞争同步资源时有无区别（代表：synchronized）

   - 自由操作资源：**无锁**
     - 思想：多线程CAS修改

   - 同一个线程执行同步资源时自动获取资源：**偏向锁**
     - 背景：在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争；
     - 思想：当只有一个线程访问同步代码块时，线程一直占有锁，直到有多个线程时开始自旋竞争。
   - 多个线程竞争同步资源时，没有获取资源的线程自旋等待：**轻量级锁**
     - 思想：当锁是偏向锁时，被另外的线程所访问，偏向锁就会升级为轻量级锁，多线程CAS获取锁；
   - 多个线程竞争同步资源时，没有获取资源的线程阻塞等待：**重量级锁**

4. 多个线程竞争锁时是否需要排队（代表：ReentrantLock）

   - 需要：**公平锁**
   - 不需要：**非公平锁**

5. 一个线程多个流程中能否获取同一把锁（代表：synchronized、ReentrantLock）

   - 可以：**可重入锁**
   - 不可以：**非可重入锁**

6. 多个线程能否共享一把锁（代表：ReentrantReadWriteLock）

   - 可以：**共享锁**
   - 不可以：**排它锁**



## Java线程通信方式

1. synchronized + notify + wait
2. lock + condition
3. volatile + Atomic类
4. cyclicBarrier API
5. 阻塞队列









